// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package mainmodule.actions;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;
import mainmodule.proxies.GroupedListening;
import mainmodule.proxies.Listening;

public class JV_GroupedListening_Create extends UserAction<java.util.List<IMendixObject>>
{
	/** @deprecated use com.mendix.utils.ListUtils.map(ListeningList, com.mendix.systemwideinterfaces.core.IEntityProxy::getMendixObject) instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final java.util.List<IMendixObject> __ListeningList;
	private final java.util.List<mainmodule.proxies.Listening> ListeningList;

	public JV_GroupedListening_Create(
		IContext context,
		java.util.List<IMendixObject> _listeningList
	)
	{
		super(context);
		this.__ListeningList = _listeningList;
		this.ListeningList = java.util.Optional.ofNullable(_listeningList)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(listeningListElement -> mainmodule.proxies.Listening.initialize(getContext(), listeningListElement))
			.collect(java.util.stream.Collectors.toList());
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
		if (ListeningList == null || ListeningList.isEmpty()) {
			return Collections.emptyList();
		}

		// Group by calendar day (UTC), ignoring time within the day
		Map<Long, Integer> countsByEpochDay = new LinkedHashMap<>(); // key: LocalDate.toEpochDay()
		LocalDate earliestDate = null;
		LocalDate latestDate = LocalDate.now(ZoneOffset.UTC); // Always use today as latest

		for (Listening l : ListeningList) {
			Date d = (Date) l.getDate();
			if (d == null) continue;
			Instant inst = d.toInstant();
			LocalDate day = inst.atZone(ZoneOffset.UTC).toLocalDate();
			long epochDay = day.toEpochDay();
			countsByEpochDay.put(epochDay, countsByEpochDay.getOrDefault(epochDay, 0) + 1);
			
			// Track earliest date only
			if (earliestDate == null || day.isBefore(earliestDate)) {
				earliestDate = day;
			}
		}

		List<IMendixObject> result = new ArrayList<>();
		
		// Fill in all days from earliest to latest, including gaps with 0 count
		if (earliestDate != null && latestDate != null) {
			LocalDate currentDate = earliestDate;
			while (!currentDate.isAfter(latestDate)) {
				long epochDay = currentDate.toEpochDay();
				int count = countsByEpochDay.getOrDefault(epochDay, 0);
				
				GroupedListening g = new GroupedListening(getContext());
				g.setDateListening(Date.from(currentDate.atStartOfDay(ZoneOffset.UTC).toInstant()));
				g.setQuantityListening(count);
				result.add(g.getMendixObject());
				
				currentDate = currentDate.plusDays(1);
			}
		}

		return result;
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "JV_GroupedListening_Create";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
